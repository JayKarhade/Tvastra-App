{"id":"../node_modules/nexmo/lib/HashGenerator.js","dependencies":[{"name":"/home/harpal/Konfinity/css/package.json","includedInParent":true,"mtime":1586415617677},{"name":"/home/harpal/Konfinity/css/node_modules/nexmo/package.json","includedInParent":true,"mtime":1586157323327},{"name":"/home/harpal/Konfinity/css/node_modules/nexmo/.babelrc","includedInParent":true,"mtime":499162500000},{"name":"crypto","loc":{"line":7,"column":21},"parent":"/home/harpal/Konfinity/css/node_modules/nexmo/lib/HashGenerator.js","resolved":"/home/harpal/.nvm/versions/node/v12.16.1/lib/node_modules/parcel-bundler/node_modules/crypto-browserify/index.js"}],"generated":{"js":"\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar crypto = require(\"crypto\");\n\nvar HashGenerator = function () {\n  function HashGenerator() {\n    _classCallCheck(this, HashGenerator);\n  }\n\n  _createClass(HashGenerator, [{\n    key: \"generate\",\n\n    /**\n     * Generate a Signature Hash.\n     *\n     * @param {String} method - the method to be used when creating the hash\n     * @param {String} secret - the secret to be used when creating the hash\n     * @param {Object} params - params to generate hash from\n     *\n     * @returns {String} the generated token\n     */\n    value: function generate(method, secret, params) {\n      params = params || {};\n      var signedQuery = \"\";\n\n      params = JSON.parse(JSON.stringify(params));\n\n      if (params.sig) {\n        delete params.sig;\n      }\n\n      Object.keys(params).sort().forEach(function (key) {\n        // replace & and = with _\n        signedQuery += \"&\" + key + \"=\" + params[key].replace(/\\&|\\=/g, \"_\");\n      });\n\n      var hash = \"\";\n\n      switch (method) {\n        case \"md5hash\":\n          signedQuery += secret;\n          hash = crypto.createHash(\"md5\").update(signedQuery).digest(\"hex\");\n          break;\n        case \"md5\":\n        case \"sha1\":\n        case \"sha256\":\n        case \"sha512\":\n          hash = crypto.createHmac(method, secret).update(signedQuery).digest(\"hex\");\n          break;\n\n        default:\n          throw \"Unknown signature algorithm: \" + method + \". Expected: md5hash, md5, sha1, sha256, or sha512\";\n      }\n\n      return hash;\n    }\n  }]);\n\n  return HashGenerator;\n}();\n\nmodule.exports = HashGenerator;\n"},"sourceMaps":{"js":{"version":3,"sources":["../src/HashGenerator.js"],"names":["crypto","require","HashGenerator","method","secret","params","signedQuery","JSON","parse","stringify","sig","Object","keys","sort","forEach","key","replace","hash","createHash","update","digest","createHmac","module","exports"],"mappings":";;;;;;AAAA,IAAMA,SAASC,QAAQ,QAAR,CAAf;;IAEMC,a;;;;;;;;AACJ;;;;;;;;;6BASSC,M,EAAQC,M,EAAQC,M,EAAQ;AAC/BA,eAASA,UAAU,EAAnB;AACA,UAAIC,cAAc,EAAlB;;AAEAD,eAASE,KAAKC,KAAL,CAAWD,KAAKE,SAAL,CAAeJ,MAAf,CAAX,CAAT;;AAEA,UAAIA,OAAOK,GAAX,EAAgB;AACd,eAAOL,OAAOK,GAAd;AACD;;AAEDC,aAAOC,IAAP,CAAYP,MAAZ,EACGQ,IADH,GAEGC,OAFH,CAEW,eAAO;AACd;AACAR,uBAAe,MAAMS,GAAN,GAAY,GAAZ,GAAkBV,OAAOU,GAAP,EAAYC,OAAZ,CAAoB,QAApB,EAA8B,GAA9B,CAAjC;AACD,OALH;;AAOA,UAAIC,OAAO,EAAX;;AAEA,cAAQd,MAAR;AACE,aAAK,SAAL;AACEG,yBAAeF,MAAf;AACAa,iBAAOjB,OACJkB,UADI,CACO,KADP,EAEJC,MAFI,CAEGb,WAFH,EAGJc,MAHI,CAGG,KAHH,CAAP;AAIA;AACF,aAAK,KAAL;AACA,aAAK,MAAL;AACA,aAAK,QAAL;AACA,aAAK,QAAL;AACEH,iBAAOjB,OACJqB,UADI,CACOlB,MADP,EACeC,MADf,EAEJe,MAFI,CAEGb,WAFH,EAGJc,MAHI,CAGG,KAHH,CAAP;AAIA;;AAEF;AACE,kDAAsCjB,MAAtC;AAnBJ;;AAsBA,aAAOc,IAAP;AACD;;;;;;AAGHK,OAAOC,OAAP,GAAiBrB,aAAjB","file":"HashGenerator.js","sourcesContent":["const crypto = require(\"crypto\");\n\nclass HashGenerator {\n  /**\n   * Generate a Signature Hash.\n   *\n   * @param {String} method - the method to be used when creating the hash\n   * @param {String} secret - the secret to be used when creating the hash\n   * @param {Object} params - params to generate hash from\n   *\n   * @returns {String} the generated token\n   */\n  generate(method, secret, params) {\n    params = params || {};\n    var signedQuery = \"\";\n\n    params = JSON.parse(JSON.stringify(params));\n\n    if (params.sig) {\n      delete params.sig;\n    }\n\n    Object.keys(params)\n      .sort()\n      .forEach(key => {\n        // replace & and = with _\n        signedQuery += \"&\" + key + \"=\" + params[key].replace(/\\&|\\=/g, \"_\");\n      });\n\n    var hash = \"\";\n\n    switch (method) {\n      case \"md5hash\":\n        signedQuery += secret;\n        hash = crypto\n          .createHash(\"md5\")\n          .update(signedQuery)\n          .digest(\"hex\");\n        break;\n      case \"md5\":\n      case \"sha1\":\n      case \"sha256\":\n      case \"sha512\":\n        hash = crypto\n          .createHmac(method, secret)\n          .update(signedQuery)\n          .digest(\"hex\");\n        break;\n\n      default:\n        throw `Unknown signature algorithm: ${method}. Expected: md5hash, md5, sha1, sha256, or sha512`;\n    }\n\n    return hash;\n  }\n}\n\nmodule.exports = HashGenerator;\n"]}},"error":null,"hash":"b9d5e0d179b16c1d3cc641d19dcc151f","cacheData":{"env":{}}}